// Package ionosdomains provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package ionosdomains

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for RunningTransfersResponseTenantTransferType.
const (
	RunningTransfersResponseTenantTransferTypeEXTERNAL    RunningTransfersResponseTenantTransferType = "EXTERNAL"
	RunningTransfersResponseTenantTransferTypeINTERTENANT RunningTransfersResponseTenantTransferType = "INTER_TENANT"
	RunningTransfersResponseTenantTransferTypeINTRATENANT RunningTransfersResponseTenantTransferType = "INTRA_TENANT"
)

// Defines values for RunningTransfersResponseTransferStatus.
const (
	RunningTransfersResponseTransferStatusFOA               RunningTransfersResponseTransferStatus = "FOA"
	RunningTransfersResponseTransferStatusFOA2              RunningTransfersResponseTransferStatus = "FOA2"
	RunningTransfersResponseTransferStatusPENDING           RunningTransfersResponseTransferStatus = "PENDING"
	RunningTransfersResponseTransferStatusREGISTRYPENDING   RunningTransfersResponseTransferStatus = "REGISTRY_PENDING"
	RunningTransfersResponseTransferStatusRUNNING           RunningTransfersResponseTransferStatus = "RUNNING"
	RunningTransfersResponseTransferStatusSIXTYDAYSLOCK     RunningTransfersResponseTransferStatus = "SIXTY_DAYS_LOCK"
	RunningTransfersResponseTransferStatusTRANSFERLOCKSET   RunningTransfersResponseTransferStatus = "TRANSFER_LOCK_SET"
	RunningTransfersResponseTransferStatusWAITINGFORRELEASE RunningTransfersResponseTransferStatus = "WAITING_FOR_RELEASE"
	RunningTransfersResponseTransferStatusWRONGAUTHINFO     RunningTransfersResponseTransferStatus = "WRONG_AUTHINFO"
)

// Defines values for RunningTransfersResponseTransferType.
const (
	TRANSFERIN  RunningTransfersResponseTransferType = "TRANSFER_IN"
	TRANSFEROUT RunningTransfersResponseTransferType = "TRANSFER_OUT"
)

// Defines values for AddressCountryCode.
const (
	AT AddressCountryCode = "AT"
	AX AddressCountryCode = "AX"
	BE AddressCountryCode = "BE"
	BG AddressCountryCode = "BG"
	CA AddressCountryCode = "CA"
	CY AddressCountryCode = "CY"
	CZ AddressCountryCode = "CZ"
	DE AddressCountryCode = "DE"
	DK AddressCountryCode = "DK"
	EE AddressCountryCode = "EE"
	ES AddressCountryCode = "ES"
	FI AddressCountryCode = "FI"
	FR AddressCountryCode = "FR"
	GB AddressCountryCode = "GB"
	GF AddressCountryCode = "GF"
	GI AddressCountryCode = "GI"
	GP AddressCountryCode = "GP"
	GR AddressCountryCode = "GR"
	HU AddressCountryCode = "HU"
	IE AddressCountryCode = "IE"
	IS AddressCountryCode = "IS"
	IT AddressCountryCode = "IT"
	LI AddressCountryCode = "LI"
	LT AddressCountryCode = "LT"
	LU AddressCountryCode = "LU"
	LV AddressCountryCode = "LV"
	MQ AddressCountryCode = "MQ"
	MT AddressCountryCode = "MT"
	MX AddressCountryCode = "MX"
	NL AddressCountryCode = "NL"
	NO AddressCountryCode = "NO"
	PL AddressCountryCode = "PL"
	PT AddressCountryCode = "PT"
	RE AddressCountryCode = "RE"
	RO AddressCountryCode = "RO"
	SE AddressCountryCode = "SE"
	SI AddressCountryCode = "SI"
	SK AddressCountryCode = "SK"
	US AddressCountryCode = "US"
)

// Defines values for ComplianceStatusType.
const (
	DATAQUALITYRUNNING       ComplianceStatusType = "DATA_QUALITY_RUNNING"
	EMAILVERIFICATIONLOCK    ComplianceStatusType = "EMAIL_VERIFICATION_LOCK"
	EMAILVERIFICATIONRUNNING ComplianceStatusType = "EMAIL_VERIFICATION_RUNNING"
	NOMINETLOCKED            ComplianceStatusType = "NOMINET_LOCKED"
)

// Defines values for ContactType.
const (
	HOSTMASTER ContactType = "HOSTMASTER"
	PRIVATE    ContactType = "PRIVATE"
	USERDATA   ContactType = "USER_DATA"
)

// Defines values for DataQualityRequestAction.
const (
	VALIDATE DataQualityRequestAction = "VALIDATE"
)

// Defines values for DomainLargeDomainType.
const (
	DomainLargeDomainTypeDOMAIN  DomainLargeDomainType = "DOMAIN"
	DomainLargeDomainTypeXDOMAIN DomainLargeDomainType = "X_DOMAIN"
)

// Defines values for DomainsSlimDomainType.
const (
	DomainsSlimDomainTypeDOMAIN  DomainsSlimDomainType = "DOMAIN"
	DomainsSlimDomainTypeXDOMAIN DomainsSlimDomainType = "X_DOMAIN"
)

// Defines values for DsDataAlg.
const (
	DsDataAlgN0   DsDataAlg = 0
	DsDataAlgN1   DsDataAlg = 1
	DsDataAlgN2   DsDataAlg = 2
	DsDataAlgN252 DsDataAlg = 252
	DsDataAlgN253 DsDataAlg = 253
	DsDataAlgN254 DsDataAlg = 254
	DsDataAlgN255 DsDataAlg = 255
	DsDataAlgN3   DsDataAlg = 3
	DsDataAlgN4   DsDataAlg = 4
	DsDataAlgN5   DsDataAlg = 5
)

// Defines values for DsDataDigestType.
const (
	DsDataDigestTypeN0    DsDataDigestType = 0
	DsDataDigestTypeN1    DsDataDigestType = 1
	DsDataDigestTypeN2255 DsDataDigestType = 2 - 255
)

// Defines values for EmailVerificationRequestAction.
const (
	RESENDEMAIL EmailVerificationRequestAction = "RESEND_EMAIL"
)

// Defines values for KeyDataFlags.
const (
	N256 KeyDataFlags = 256
	N257 KeyDataFlags = 257
)

// Defines values for ProcessStatusTenantTransferType.
const (
	ProcessStatusTenantTransferTypeEXTERNAL    ProcessStatusTenantTransferType = "EXTERNAL"
	ProcessStatusTenantTransferTypeINTERTENANT ProcessStatusTenantTransferType = "INTER_TENANT"
	ProcessStatusTenantTransferTypeINTRATENANT ProcessStatusTenantTransferType = "INTRA_TENANT"
)

// Defines values for ProcessStatusTransferStatus.
const (
	ProcessStatusTransferStatusAPPROVED        ProcessStatusTransferStatus = "APPROVED"
	ProcessStatusTransferStatusCANCELLED       ProcessStatusTransferStatus = "CANCELLED"
	ProcessStatusTransferStatusFOA             ProcessStatusTransferStatus = "FOA"
	ProcessStatusTransferStatusFOA2            ProcessStatusTransferStatus = "FOA2"
	ProcessStatusTransferStatusREGISTRYPENDING ProcessStatusTransferStatus = "REGISTRY_PENDING"
	ProcessStatusTransferStatusREJECTED        ProcessStatusTransferStatus = "REJECTED"
	ProcessStatusTransferStatusRUNNING         ProcessStatusTransferStatus = "RUNNING"
	ProcessStatusTransferStatusTRANSFERLOCKSET ProcessStatusTransferStatus = "TRANSFER_LOCK_SET"
	ProcessStatusTransferStatusWRONGAUTHINFO   ProcessStatusTransferStatus = "WRONG_AUTHINFO"
)

// Defines values for ProcessStatusType.
const (
	DELETEINPROGRESS      ProcessStatusType = "DELETE_IN_PROGRESS"
	TRANSFERININPROGRESS  ProcessStatusType = "TRANSFER_IN_IN_PROGRESS"
	TRANSFEROUTINPROGRESS ProcessStatusType = "TRANSFER_OUT_IN_PROGRESS"
	UPDATEFAILED          ProcessStatusType = "UPDATE_FAILED"
	UPDATEINPROGRESS      ProcessStatusType = "UPDATE_IN_PROGRESS"
)

// Defines values for ProcessStatusUpdateScope.
const (
	AUTHCODE         ProcessStatusUpdateScope = "AUTHCODE"
	AUTORENEW        ProcessStatusUpdateScope = "AUTORENEW"
	CANCELLATION     ProcessStatusUpdateScope = "CANCELLATION"
	CONTACTS         ProcessStatusUpdateScope = "CONTACTS"
	DNSSEC           ProcessStatusUpdateScope = "DNSSEC"
	DOMAINEXTENSIONS ProcessStatusUpdateScope = "DOMAIN_EXTENSIONS"
	DOMAINSTATUSES   ProcessStatusUpdateScope = "DOMAIN_STATUSES"
	GENERIC          ProcessStatusUpdateScope = "GENERIC"
	HOSTS            ProcessStatusUpdateScope = "HOSTS"
	PRIVACY          ProcessStatusUpdateScope = "PRIVACY"
)

// Defines values for ProvisioningStatusRegistrationType.
const (
	CREATE       ProvisioningStatusRegistrationType = "CREATE"
	RESTORE      ProvisioningStatusRegistrationType = "RESTORE"
	SEDOTRANSFER ProvisioningStatusRegistrationType = "SEDO_TRANSFER"
	TRANSFER     ProvisioningStatusRegistrationType = "TRANSFER"
)

// Defines values for ProvisioningStatusType.
const (
	ProvisioningStatusTypeACTIVE                 ProvisioningStatusType = "ACTIVE"
	ProvisioningStatusTypeEXPIRING               ProvisioningStatusType = "EXPIRING"
	ProvisioningStatusTypeREGISTRATIONINPROGRESS ProvisioningStatusType = "REGISTRATION_IN_PROGRESS"
)

// Defines values for ProvisioningStatusTypeType.
const (
	ProvisioningStatusTypeTypeACTIVE                 ProvisioningStatusTypeType = "ACTIVE"
	ProvisioningStatusTypeTypeEXPIRING               ProvisioningStatusTypeType = "EXPIRING"
	ProvisioningStatusTypeTypeREGISTRATIONINPROGRESS ProvisioningStatusTypeType = "REGISTRATION_IN_PROGRESS"
)

// Defines values for RequestResponseStatus.
const (
	CANCELLED                RequestResponseStatus = "CANCELLED"
	EMAILVERIFICATIONPENDING RequestResponseStatus = "EMAIL_VERIFICATION_PENDING"
	EMAILVERIFICATIONSUCCESS RequestResponseStatus = "EMAIL_VERIFICATION_SUCCESS"
	FAILED                   RequestResponseStatus = "FAILED"
	FINISHED                 RequestResponseStatus = "FINISHED"
	PENDING                  RequestResponseStatus = "PENDING"
	RUNNING                  RequestResponseStatus = "RUNNING"
)

// Defines values for RequestResponseType.
const (
	GENERATEAUTHCODE  RequestResponseType = "GENERATE_AUTHCODE"
	UPDATECONTACTS    RequestResponseType = "UPDATE_CONTACTS"
	UPDATEDNSSEC      RequestResponseType = "UPDATE_DNSSEC"
	UPDATENAMESERVERS RequestResponseType = "UPDATE_NAMESERVERS"
	UPDATEPRIVACY     RequestResponseType = "UPDATE_PRIVACY"
	UPDATESTATUSES    RequestResponseType = "UPDATE_STATUSES"
)

// Defines values for TldInfoContactTypesSupported.
const (
	Admin      TldInfoContactTypesSupported = "admin"
	Registrant TldInfoContactTypesSupported = "registrant"
	Technical  TldInfoContactTypesSupported = "technical"
)

// Defines values for TldInfoDnsSecInterface.
const (
	TldInfoDnsSecInterfaceDsData  TldInfoDnsSecInterface = "dsData"
	TldInfoDnsSecInterfaceKeyData TldInfoDnsSecInterface = "keyData"
)

// Defines values for TransferInRequestAction.
const (
	CANCEL TransferInRequestAction = "CANCEL"
	RETRY  TransferInRequestAction = "RETRY"
)

// Defines values for TransferOutRequestAction.
const (
	RESENDFOA TransferOutRequestAction = "RESEND_FOA"
)

// Defines values for GetV1DomainitemsParamsSortBy.
const (
	GetV1DomainitemsParamsSortByDOMAINNAME            GetV1DomainitemsParamsSortBy = "DOMAIN_NAME"
	GetV1DomainitemsParamsSortByPROVISIONINGSTARTDATE GetV1DomainitemsParamsSortBy = "PROVISIONING_START_DATE"
)

// Defines values for GetV1DomainitemsParamsDirection.
const (
	GetV1DomainitemsParamsDirectionASC  GetV1DomainitemsParamsDirection = "ASC"
	GetV1DomainitemsParamsDirectionDESC GetV1DomainitemsParamsDirection = "DESC"
)

// Defines values for GetV1DomainitemsDomainsParamsSortBy.
const (
	GetV1DomainitemsDomainsParamsSortByDOMAINNAME GetV1DomainitemsDomainsParamsSortBy = "DOMAIN_NAME"
)

// Defines values for GetV1DomainitemsDomainsParamsDirection.
const (
	GetV1DomainitemsDomainsParamsDirectionASC  GetV1DomainitemsDomainsParamsDirection = "ASC"
	GetV1DomainitemsDomainsParamsDirectionDESC GetV1DomainitemsDomainsParamsDirection = "DESC"
)

// Defines values for GetV1DomainitemsTldsParamsPhase.
const (
	ALL             GetV1DomainitemsTldsParamsPhase = "ALL"
	PREREGISTRATION GetV1DomainitemsTldsParamsPhase = "PREREGISTRATION"
	REGISTRATION    GetV1DomainitemsTldsParamsPhase = "REGISTRATION"
)

// PreregistrationsBody defines model for PreregistrationsBody.
type PreregistrationsBody struct {
	ItemIds *[]string `json:"itemIds,omitempty"`
}

// PreregistrationsResponse defines model for PreregistrationsResponse.
type PreregistrationsResponse struct {
	DomainName              *string `json:"domainName,omitempty"`
	GeneralAvailabilityDate *string `json:"generalAvailabilityDate,omitempty"`
	ItemId                  *string `json:"itemId,omitempty"`
	Tld                     *string `json:"tld,omitempty"`
}

// RunningTransfersResponse defines model for RunningTransfersResponse.
type RunningTransfersResponse struct {
	AutoAckDate        *string                                     `json:"autoAckDate,omitempty"`
	DomainItemId       *string                                     `json:"domainItemId,omitempty"`
	DomainName         *string                                     `json:"domainName,omitempty"`
	Foa2EmailAddress   *string                                     `json:"foa2EmailAddress,omitempty"`
	IsSedoTransfer     *bool                                       `json:"isSedoTransfer,omitempty"`
	RegcEmail          *string                                     `json:"regcEmail,omitempty"`
	StartDate          *string                                     `json:"startDate,omitempty"`
	TenantTransferType *RunningTransfersResponseTenantTransferType `json:"tenantTransferType,omitempty"`
	Tld                *string                                     `json:"tld,omitempty"`
	TransferEndDate    *string                                     `json:"transferEndDate,omitempty"`
	TransferStatus     *RunningTransfersResponseTransferStatus     `json:"transferStatus,omitempty"`
	TransferType       *RunningTransfersResponseTransferType       `json:"transferType,omitempty"`
}

// RunningTransfersResponseTenantTransferType defines model for RunningTransfersResponse.TenantTransferType.
type RunningTransfersResponseTenantTransferType string

// RunningTransfersResponseTransferStatus defines model for RunningTransfersResponse.TransferStatus.
type RunningTransfersResponseTransferStatus string

// RunningTransfersResponseTransferType defines model for RunningTransfersResponse.TransferType.
type RunningTransfersResponseTransferType string

// Address Holds address info for a postalInfo.
type Address struct {
	City *string `json:"city,omitempty"`

	// CountryCode Contry code must be specified using ISO3166 standard
	CountryCode *AddressCountryCode `json:"countryCode,omitempty"`
	PostalCode  *string             `json:"postalCode,omitempty"`
	State       *string             `json:"state,omitempty"`
	Streets     *[]string           `json:"streets,omitempty"`
}

// AddressCountryCode Contry code must be specified using ISO3166 standard
type AddressCountryCode string

// AuthCodeRequest Empty json
type AuthCodeRequest = map[string]interface{}

// ComplianceStatus defines model for complianceStatus.
type ComplianceStatus struct {
	// DomainOnHoldAfterTimeout only for status EMAIL_VERIFICATION_RUNNING. Specifies if the domain will be locked if the regc email is not verified in 14 days time.
	DomainOnHoldAfterTimeout *bool `json:"domainOnHoldAfterTimeout,omitempty"`

	// Locks only for status NOMINET_LOCKED. The types of Nominet locks set on the domain.
	Locks *struct {
		DataQuality   *NominetLockData `json:"data_quality,omitempty"`
		Investigation *NominetLockData `json:"investigation,omitempty"`
	} `json:"locks,omitempty"`

	// Reason only for DATA_QUALITY_RUNNING. The reason for which this data quality process has been started (incorrect name, wrong address or both)
	Reason *string `json:"reason,omitempty"`

	// RegistrantEmail only for EMAIL_VERIFICATION_RUNNING. The domain owner email.
	RegistrantEmail *string `json:"registrantEmail,omitempty"`

	// Type can be EMAIL_VERIFICATION_RUNNING (if the the email associated to the domain registrant must be validated) and for *.uk domains DATA_QUALITY_RUNNING, NOMINET_LOCKED or EMAIL_VERIFICATION_LOCK.
	Type *ComplianceStatusType `json:"type,omitempty"`

	// VerificationPossibleUntilDate only for status EMAIL_VERIFICATION_RUNNING. The date until the email verification process can be acked
	VerificationPossibleUntilDate *interface{} `json:"verificationPossibleUntilDate,omitempty"`
}

// ComplianceStatusType can be EMAIL_VERIFICATION_RUNNING (if the the email associated to the domain registrant must be validated) and for *.uk domains DATA_QUALITY_RUNNING, NOMINET_LOCKED or EMAIL_VERIFICATION_LOCK.
type ComplianceStatusType string

// Contact defines model for contact.
type Contact struct {
	Email *string `json:"email,omitempty"`

	// Extensions Contact extensions - see 'Contacts' section description for more details
	Extensions *ContactExtensions `json:"extensions,omitempty"`

	// Fax Fax number must be in E.164 international telephone numbers Country code (max 3 digits) followed by subscriber number (max 12 digits)
	Fax *string `json:"fax,omitempty"`

	// PostalInfo Holds postal info for a contact.
	PostalInfo *PostalInfo  `json:"postalInfo,omitempty"`
	Type       *ContactType `json:"type,omitempty"`

	// Voice Voice number must be in E.164 international telephone numbers Country code (max 3 digits) followed by subscriber number (max 12 digits)
	Voice *string `json:"voice,omitempty"`
}

// ContactType defines model for Contact.Type.
type ContactType string

// ContactExtensions Contact extensions - see 'Contacts' section description for more details
type ContactExtensions map[string]map[string]interface{}

// Contacts defines model for contacts.
type Contacts struct {
	Admin      *Contact `json:"admin,omitempty"`
	Registrant *Contact `json:"registrant,omitempty"`
	Technical  *Contact `json:"technical,omitempty"`
}

// DataQualityRequest Data quality request model
type DataQualityRequest struct {
	// Action Data quality action
	Action *DataQualityRequestAction `json:"action,omitempty"`
}

// DataQualityRequestAction Data quality action
type DataQualityRequestAction string

// DisablePrivacy defines model for disablePrivacy.
type DisablePrivacy struct {
	// Enabled disable domain privacy by setting to 'false'
	Enabled *bool `json:"enabled,omitempty"`
}

// DnsSec defines model for dnsSec.
type DnsSec struct {
	// SecDns DNS Security information. As per https://tools.ietf.org/html/rfc5910#section-3.3
	// - maxSigLife
	// - List of dsData
	// - List of keyData
	SecDns *DnsSecEntity `json:"secDns,omitempty"`
}

// DnsSecEntity DNS Security information. As per https://tools.ietf.org/html/rfc5910#section-3.3
// - maxSigLife
// - List of dsData
// - List of keyData
type DnsSecEntity struct {
	DsData  *[]DsData  `json:"dsData,omitempty"`
	KeyData *[]KeyData `json:"keyData,omitempty"`
}

// DomainLarge defines model for domainLarge.
type DomainLarge struct {
	// AuthInfo OPTIONAL - This field is hidden in case the domain has Domain Guard activated. Also, for .eu and .de domains this field is not set by default. The client should explicitly generate it in order to exist.
	AuthInfo  *string `json:"authInfo,omitempty"`
	AutoRenew *bool   `json:"autoRenew,omitempty"`

	// CancelOnExpire Indicates whether the domain will be cancelled at the expiration date. When provisioning status is EXPIRING fields revivePossibleUntilDate and expirationDateIfRevived are hidden.
	CancelOnExpire *bool `json:"cancelOnExpire,omitempty"`

	// CancellationDate OPTIONAL - This field is used to replace the autorenew flag, when the domain expiration date is not synchronized with the contract billing date of the domain.
	CancellationDate *time.Time `json:"cancellationDate,omitempty"`

	// DnsSecEnabled Indicates whether the DNS sucurity extensions are turned on/off
	DnsSecEnabled *bool `json:"dnsSecEnabled,omitempty"`
	DomainLock    *bool `json:"domainLock,omitempty"`

	// DomainType Domain type
	DomainType *DomainLargeDomainType `json:"domainType,omitempty"`

	// EncodedName OPTIONAL - Appears only in case of IDN domain names
	EncodedName *string `json:"encodedName,omitempty"`

	// ExpirationDate Domain expiration date
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	// Id Unique domain identifier
	Id *string `json:"id,omitempty"`

	// Name Domain name
	Name *string `json:"name,omitempty"`

	// PendingProvisioning Flag for pending provisioning items
	PendingProvisioning *bool `json:"pendingProvisioning,omitempty"`

	// PrivacyEnabled Indicates whether the domain privacy is turned on/off
	PrivacyEnabled *bool       `json:"privacyEnabled,omitempty"`
	Status         *ItemStatus `json:"status,omitempty"`

	// Tld Top level domain name
	Tld          *string `json:"tld,omitempty"`
	TransferLock *bool   `json:"transferLock,omitempty"`
}

// DomainLargeDomainType Domain type
type DomainLargeDomainType string

// DomainNameValidationRequest List of domain names to be validated
type DomainNameValidationRequest = []string

// DomainSmall defines model for domainSmall.
type DomainSmall struct {
	// EncodedName OPTIONAL - Appears only in case of IDN domain names
	EncodedName *string `json:"encodedName,omitempty"`

	// Id Unique domain identifier
	Id *string `json:"id,omitempty"`

	// Name Domain name
	Name *string `json:"name,omitempty"`

	// PendingProvisioning Pending provisioning flag
	PendingProvisioning *bool       `json:"pendingProvisioning,omitempty"`
	Status              *ItemStatus `json:"status,omitempty"`

	// Tld Top level domain name
	Tld *string `json:"tld,omitempty"`
}

// DomainStatusesRequest Map containg domainStatuses
type DomainStatusesRequest struct {
	// DomainStatuses Map containing domain statuses such as clientDeleteProhibited, clientHold, clientRenewProhibited, clientTransferProhibited, clientUpdateProhibited and their associated reasons
	DomainStatuses *struct {
		// DomainStatusName It can have any value from the following - clientDeleteProhibited, clientHold, clientRenewProhibited, clientTransferProhibited, clientUpdateProhibited
		DomainStatusName *struct {
			Reasons *[]struct {
				// Intent OPTIONAL - The intent of the status. If not specified, by default its value will be set to 'client_request'.
				Intent *string `json:"intent,omitempty"`
			} `json:"reasons,omitempty"`
			Value *bool `json:"value,omitempty"`
		} `json:"domainStatusName,omitempty"`
	} `json:"domainStatuses,omitempty"`
}

// DomainStatusesResponse Map containing domain statuses such as clientDeleteProhibited, clientHold, clientRenewProhibited, clientTransferProhibited, clientUpdateProhibited and their associated reasons
type DomainStatusesResponse struct {
	DomainStatuses *struct {
		// DomainStatusName It can have any value from the following - clientDeleteProhibited, clientHold, clientRenewProhibited, clientTransferProhibited, clientUpdateProhibited
		DomainStatusName *struct {
			Reasons *[]struct {
				// CreatedBy Who created the status.
				CreatedBy *string `json:"createdBy,omitempty"`

				// DueDate OPTIONAL - The date until the specified reason applies. After this date, the status is no longer active and will be removed. If the last remaining reason of a status expires, the status will be removed from the domain.
				DueDate *time.Time `json:"dueDate,omitempty"`

				// Intent The reason for which the status has been set.
				Intent *string `json:"intent,omitempty"`

				// Timestamp The date when the status has been set on the domain.
				Timestamp *time.Time `json:"timestamp,omitempty"`
			} `json:"reasons,omitempty"`
			Value *bool `json:"value,omitempty"`
		} `json:"domainStatusName,omitempty"`
	} `json:"domainStatuses,omitempty"`
}

// Domains defines model for domains.
type Domains struct {
	Count   *int32         `json:"count,omitempty"`
	Domains *[]DomainSmall `json:"domains,omitempty"`
}

// DomainsSlim defines model for domainsSlim.
type DomainsSlim struct {
	// DomainType Domain type
	DomainType *DomainsSlimDomainType `json:"domainType,omitempty"`

	// Id Unique domain identifier
	Id *string `json:"id,omitempty"`

	// Name Domain name
	Name *string `json:"name,omitempty"`

	// PendingProvisioning OPTIONAL - Pending provisioning flag
	PendingProvisioning      *bool                     `json:"pendingProvisioning,omitempty"`
	SimpleProvisioningStatus *SimpleProvisioningStatus `json:"provisioningStatus,omitempty"`
}

// DomainsSlimDomainType Domain type
type DomainsSlimDomainType string

// DsData The digest type - digestType - field in the model identifies the
// cryptographic digest algorithm used by the resource record.  The
// following table lists the currently defined digest algorithm types.
// Value | Algorithm | Status
// ----- | --------  | -----
// 0     | Reserved  |  -
// 1     | SHA-1     | MANDATORY
// 2-255 | Unassigned|  -
//
// The Algorithm field - alg - identifies the public key's cryptographic algorithm and determines the format of the Public Key field
// The DNSKEY, RRSIG, and DS RRs use an 8-bit number to identify the
// security algorithm being used.  These values are stored in the
// "Algorithm number" field in the resource record RDATA.
//
// Some algorithms are usable only for zone signing (DNSSEC), some only
// for transaction security mechanisms (SIG(0) and TSIG), and some for
// both.  Those usable for zone signing may appear in DNSKEY, RRSIG, and
// DS RRs.  Those usable for transaction security would be present in
// SIG(0) and KEY RRs, as described in [RFC 2931].
//
// Value | Algorithm
// ----- | --------
// 0     | reserved
// 1     | RSA/MD5 [RSAMD5]
// 2     | Diffie-Hellman [DH]
// 3     | DSA/SHA-1 [DSA]
// 4     | Elliptic Curve [ECC]
// 5     | RSA/SHA-1 [RSASHA1]
// 252   | Indirect [INDIRECT]
// 253   | Private [PRIVATEDNS]
// 254   | Private [PRIVATEOID]
// 255   | reserved
// 6 - 251  Available for assignment by IETF Standards Action.
type DsData struct {
	// Alg The Algorithm field identifies the public key's cryptographic algorithm and determines the format of the Public Key field
	Alg *DsDataAlg `json:"alg,omitempty"`

	// Digest The DS record refers to a DNSKEY RR by including a digest of that DNSKEY RR.The digest is calculated by concatenating the canonical form of the fully qualified owner name of the DNSKEY RR with the DNSKEY RDATA, and then applying the digest algorithm.
	Digest *string `json:"digest,omitempty"`

	// DigestType The cryptographic digest algorithm used by the resource record
	DigestType *DsDataDigestType `json:"digestType,omitempty"`

	// KeyData The Key Data Interface relies on the use of the <secDNS:keyData>
	// element for creates, adds, removes, and <domain:info> responses.  The
	// DS information is not provided by the client but is generated by the
	// server.  The attributes used for DS generation are based on server
	// policy, where only key data is passed between the client and the server.
	//
	// The flags field - flags - can have bit 7 of the Flags field is the Zone Key flag.  If bit 7 has value 1,
	// then the DNSKEY record holds a DNS zone key, and the DNSKEY RR's
	// owner name MUST be the name of a zone.  If bit 7 has value 0, then
	// the DNSKEY record holds some other type of DNS public key and MUST
	// NOT be used to verify RRSIGs that cover RRsets.
	//
	// Bit 15 of the Flags field is the Secure Entry Point flag, described
	// in [RFC3757].  If bit 15 has value 1, then the DNSKEY record holds a
	// key intended for use as a secure entry point.  This flag is only
	// intended to be a hint to zone signing or debugging software as to the
	// intended use of this DNSKEY record; validators MUST NOT alter their
	// behavior during the signature validation process in any way based on
	// the setting of this bit.  This also means that a DNSKEY RR with the
	// SEP bit set would also need the Zone Key flag set in order to be able
	// to generate signatures legally.  A DNSKEY RR with the SEP set and the
	// Zone Key flag not set MUST NOT be used to verify RRSIGs that cover RRsets.
	// Bits 0-6 and 8-14 are reserved: these bits MUST have value 0 upon
	// creation of the DNSKEY RR and MUST be ignored upon receipt.
	//
	// The Algorithm field - alg - identifies the public key's cryptographic algorithm and determines the format of the Public Key field
	// The DNSKEY, RRSIG, and DS RRs use an 8-bit number to identify the
	// security algorithm being used.  These values are stored in the
	// "Algorithm number" field in the resource record RDATA.
	//
	// Some algorithms are usable only for zone signing (DNSSEC), some only
	// for transaction security mechanisms (SIG(0) and TSIG), and some for
	// both.  Those usable for zone signing may appear in DNSKEY, RRSIG, and
	// DS RRs.  Those usable for transaction security would be present in
	// SIG(0) and KEY RRs, as described in [RFC 2931].
	//
	// Value | Algorithm
	// ----- | --------
	// 0     | reserved
	// 1     | RSA/MD5 [RSAMD5]
	// 2     | Diffie-Hellman [DH]
	// 3     | DSA/SHA-1 [DSA]
	// 4     | Elliptic Curve [ECC]
	// 5     | RSA/SHA-1 [RSASHA1]
	// 252   | Indirect [INDIRECT]
	// 253   | Private [PRIVATEDNS]
	// 254   | Private [PRIVATEOID]
	// 255   | reserved
	// 6 - 251  Available for assignment by IETF Standards Action.
	KeyData *KeyData `json:"keyData,omitempty"`

	// KeyTag The Key Tag field contains the key tag value of the DNSKEY RR that validates this signature, in network byte order
	KeyTag *int `json:"keyTag,omitempty"`
}

// DsDataAlg The Algorithm field identifies the public key's cryptographic algorithm and determines the format of the Public Key field
type DsDataAlg int

// DsDataDigestType The cryptographic digest algorithm used by the resource record
type DsDataDigestType int

// EmailVerificationRequest Email verification request model
type EmailVerificationRequest struct {
	// Action Email verification action
	Action *EmailVerificationRequestAction `json:"action,omitempty"`
}

// EmailVerificationRequestAction Email verification action
type EmailVerificationRequestAction string

// EmailVerificationResponse Email verification response model
type EmailVerificationResponse struct {
	// RegcEmail The regc email to be verified
	RegcEmail *string `json:"regcEmail,omitempty"`
}

// Error Generic error model
type Error struct {
	// Code The error code.
	Code *string `json:"code,omitempty"`

	// Fields List of request payload fields causing the error
	Fields *[]string `json:"fields,omitempty"`

	// Message The error message.
	Message *string `json:"message,omitempty"`

	// Parameters List of query parameters causing the error
	Parameters *[]string `json:"parameters,omitempty"`
}

// ItemStatus defines model for itemStatus.
type ItemStatus struct {
	ComplianceStatus   *ComplianceStatus   `json:"complianceStatus,omitempty"`
	ProcessStatus      *ProcessStatus      `json:"processStatus,omitempty"`
	ProvisioningStatus *ProvisioningStatus `json:"provisioningStatus,omitempty"`
}

// KeyData The Key Data Interface relies on the use of the <secDNS:keyData>
// element for creates, adds, removes, and <domain:info> responses.  The
// DS information is not provided by the client but is generated by the
// server.  The attributes used for DS generation are based on server
// policy, where only key data is passed between the client and the server.
//
// The flags field - flags - can have bit 7 of the Flags field is the Zone Key flag.  If bit 7 has value 1,
// then the DNSKEY record holds a DNS zone key, and the DNSKEY RR's
// owner name MUST be the name of a zone.  If bit 7 has value 0, then
// the DNSKEY record holds some other type of DNS public key and MUST
// NOT be used to verify RRSIGs that cover RRsets.
//
// Bit 15 of the Flags field is the Secure Entry Point flag, described
// in [RFC3757].  If bit 15 has value 1, then the DNSKEY record holds a
// key intended for use as a secure entry point.  This flag is only
// intended to be a hint to zone signing or debugging software as to the
// intended use of this DNSKEY record; validators MUST NOT alter their
// behavior during the signature validation process in any way based on
// the setting of this bit.  This also means that a DNSKEY RR with the
// SEP bit set would also need the Zone Key flag set in order to be able
// to generate signatures legally.  A DNSKEY RR with the SEP set and the
// Zone Key flag not set MUST NOT be used to verify RRSIGs that cover RRsets.
// Bits 0-6 and 8-14 are reserved: these bits MUST have value 0 upon
// creation of the DNSKEY RR and MUST be ignored upon receipt.
//
// The Algorithm field - alg - identifies the public key's cryptographic algorithm and determines the format of the Public Key field
// The DNSKEY, RRSIG, and DS RRs use an 8-bit number to identify the
// security algorithm being used.  These values are stored in the
// "Algorithm number" field in the resource record RDATA.
//
// Some algorithms are usable only for zone signing (DNSSEC), some only
// for transaction security mechanisms (SIG(0) and TSIG), and some for
// both.  Those usable for zone signing may appear in DNSKEY, RRSIG, and
// DS RRs.  Those usable for transaction security would be present in
// SIG(0) and KEY RRs, as described in [RFC 2931].
//
// Value | Algorithm
// ----- | --------
// 0     | reserved
// 1     | RSA/MD5 [RSAMD5]
// 2     | Diffie-Hellman [DH]
// 3     | DSA/SHA-1 [DSA]
// 4     | Elliptic Curve [ECC]
// 5     | RSA/SHA-1 [RSASHA1]
// 252   | Indirect [INDIRECT]
// 253   | Private [PRIVATEDNS]
// 254   | Private [PRIVATEOID]
// 255   | reserved
// 6 - 251  Available for assignment by IETF Standards Action.
type KeyData struct {
	// Alg The Algorithm field identifies the public key's cryptographic algorithm and determines the format of the Public Key field.
	Alg *int `json:"alg,omitempty"`

	// Flags flags field
	Flags *KeyDataFlags `json:"flags,omitempty"`

	// Protocol The Protocol Field MUST have value 3, and the DNSKEY RR MUST be treated as invalid during signature verification if it is found to be some value other than 3
	Protocol *int `json:"protocol,omitempty"`

	// PubKey The Public Key Field holds the public key material.  The format depends on the algorithm of the key being stored and is described in separate documents.
	PubKey *string `json:"pubKey,omitempty"`
}

// KeyDataFlags flags field
type KeyDataFlags int

// Nameserver defines model for nameserver.
type Nameserver struct {
	// IpV4Addresses list of IPv4 addresses
	IpV4Addresses *[]string `json:"ipV4Addresses,omitempty"`

	// IpV6Addresses list of IPv6 addresses. Any IPv6 format (long, short, normalized) is accepted
	IpV6Addresses *[]string `json:"ipV6Addresses,omitempty"`

	// Name nameserver name
	Name *string `json:"name,omitempty"`
}

// NameserverGetResponse defines model for nameserver-get-response.
type NameserverGetResponse struct {
	// Nameservers list of nameservers
	Nameservers *[]Nameserver `json:"nameservers,omitempty"`

	// Type nameserver type (CUSTOM or DEFAULT)
	Type *string `json:"type,omitempty"`
}

// Nameservers list of nameservers
type Nameservers = []Nameserver

// NominetLockData defines model for nominetLockData.
type NominetLockData struct {
	// Reason OPTIONAL - the reason this lock is set
	Reason *string `json:"reason,omitempty"`
}

// PostalInfo Holds postal info for a contact.
type PostalInfo struct {
	// Address Holds address info for a postalInfo.
	Address      Address `json:"address"`
	FirstName    *string `json:"firstName,omitempty"`
	LastName     *string `json:"lastName,omitempty"`
	Name         *string `json:"name,omitempty"`
	Organization *string `json:"organization,omitempty"`
	Salutation   *string `json:"salutation,omitempty"`
}

// ProcessStatus defines model for processStatus.
type ProcessStatus struct {
	// Errors only for UPDATE_FAILED status. Contains the reason why the update ended in failure.
	Errors *[]Error `json:"errors,omitempty"`

	// Foa2EmailAddress the email address for FOA2, only in case of TRANSFER_OUT_IN_PROGRESS
	Foa2EmailAddress *string `json:"foa2EmailAddress,omitempty"`

	// TenantTransferType only for TRANSFER_IN_IN_PROGRESS and TRANSFER_OUT_IN_PROGRESS.
	TenantTransferType *ProcessStatusTenantTransferType `json:"tenantTransferType,omitempty"`

	// TransferEndDate only for status TRANSFER_IN_IN_PROGRESS. The date when the transfer will be cancelled automatically if no other interaction occurs.
	TransferEndDate *interface{} `json:"transferEndDate,omitempty"`

	// TransferStatus only for TRANSFER_IN_IN_PROGRESS and TRANSFER_OUT_IN_PROGRESS
	TransferStatus *ProcessStatusTransferStatus `json:"transferStatus,omitempty"`

	// Type can be UPDATE_IN_PROGRESS, TRANSFER_OUT_IN_PROGRESS, TRANSFER_IN_IN_PROGRESS, DELETE_IN_PROGRESS (for running processes) or UPDATE_FAILED (if the last update performed on this domain was unsuccessful).
	Type *ProcessStatusType `json:"type,omitempty"`

	// UpdateScope only for UPDATE_IN_PROGRESS and UPDATE_FAILED statuses. Specifies which parts of the domain are being updated (contacts, hosts, statuses, extensions, privacy, autorenew etc).
	UpdateScope *[]ProcessStatusUpdateScope `json:"updateScope,omitempty"`
}

// ProcessStatusTenantTransferType only for TRANSFER_IN_IN_PROGRESS and TRANSFER_OUT_IN_PROGRESS.
type ProcessStatusTenantTransferType string

// ProcessStatusTransferStatus only for TRANSFER_IN_IN_PROGRESS and TRANSFER_OUT_IN_PROGRESS
type ProcessStatusTransferStatus string

// ProcessStatusType can be UPDATE_IN_PROGRESS, TRANSFER_OUT_IN_PROGRESS, TRANSFER_IN_IN_PROGRESS, DELETE_IN_PROGRESS (for running processes) or UPDATE_FAILED (if the last update performed on this domain was unsuccessful).
type ProcessStatusType string

// ProcessStatusUpdateScope defines model for ProcessStatus.UpdateScope.
type ProcessStatusUpdateScope string

// ProvisioningStatus defines model for provisioningStatus.
type ProvisioningStatus struct {
	// IsAutorenewSwitchable only for status ACTIVE and  includeDomainStatus field set to true.
	IsAutorenewSwitchable *bool `json:"isAutorenewSwitchable,omitempty"`

	// RegistrationType only for REGISTRATION_IN_PROGRESS.
	RegistrationType *ProvisioningStatusRegistrationType `json:"registrationType,omitempty"`

	// RevivePossibleUntilDate only for status EXPIRING. The date until the domain can be restored (if possible).
	RevivePossibleUntilDate *time.Time `json:"revivePossibleUntilDate,omitempty"`

	// SetToExpireOn only for status ACTIVE. The date when the domain will expire.
	SetToExpireOn *time.Time `json:"setToExpireOn,omitempty"`

	// SetToRenewOn only for status ACTIVE. The date when the domain will be renewed.
	SetToRenewOn *time.Time `json:"setToRenewOn,omitempty"`

	// Type can be REGISTRATION_IN_PROGRESS (if the domain has not yet been provisioned), EXPIRING (if the domain is ready to be deleted) or ACTIVE (the general state of a provisioned domain item).
	Type *ProvisioningStatusType `json:"type,omitempty"`
}

// ProvisioningStatusRegistrationType only for REGISTRATION_IN_PROGRESS.
type ProvisioningStatusRegistrationType string

// ProvisioningStatusType can be REGISTRATION_IN_PROGRESS (if the domain has not yet been provisioned), EXPIRING (if the domain is ready to be deleted) or ACTIVE (the general state of a provisioned domain item).
type ProvisioningStatusType string

// SimpleProvisioningStatus defines model for provisioningStatusType.
type SimpleProvisioningStatus struct {
	// Type can be REGISTRATION_IN_PROGRESS (if the domain has not yet been provisioned), EXPIRING (if the domain is ready to be deleted) or ACTIVE (the general state of a provisioned domain item).
	Type *ProvisioningStatusTypeType `json:"type,omitempty"`
}

// ProvisioningStatusTypeType can be REGISTRATION_IN_PROGRESS (if the domain has not yet been provisioned), EXPIRING (if the domain is ready to be deleted) or ACTIVE (the general state of a provisioned domain item).
type ProvisioningStatusTypeType string

// RequestId The id of the processed request.
type RequestId struct {
	Id *string `json:"id,omitempty"`
}

// RequestResponse Status of request.
type RequestResponse struct {
	Details *string                `json:"details,omitempty"`
	Errors  *string                `json:"errors,omitempty"`
	Id      *string                `json:"id,omitempty"`
	Status  *RequestResponseStatus `json:"status,omitempty"`
	Type    *RequestResponseType   `json:"type,omitempty"`
}

// RequestResponseStatus defines model for RequestResponse.Status.
type RequestResponseStatus string

// RequestResponseType defines model for RequestResponse.Type.
type RequestResponseType string

// TldInfo Information regarding supported features of a specific TLD
type TldInfo struct {
	// AuthInfoChangeSupported flag showing if authInfo can be changed
	AuthInfoChangeSupported *bool `json:"authInfoChangeSupported,omitempty"`

	// AuthInfoSupported flag describing if authInfo is supported by the registry
	AuthInfoSupported *bool `json:"authInfoSupported,omitempty"`

	// AutorenewSupported flag regarding the autorenew feature which automatically enables the renew of the domain after expiration date
	AutorenewSupported *bool `json:"autorenewSupported,omitempty"`

	// ClientDeleteProhibitedSupported flag showing if the clientDeleteProhibited status is supported for a domain
	ClientDeleteProhibitedSupported *bool `json:"clientDeleteProhibitedSupported,omitempty"`

	// ClientHoldSupported flag showing if the clientHold status is supported for a domain
	ClientHoldSupported *bool `json:"clientHoldSupported,omitempty"`

	// ClientRenewProhibitedSupported flag showing if the clientRenewProhibited status is supported for a domain
	ClientRenewProhibitedSupported *bool `json:"clientRenewProhibitedSupported,omitempty"`

	// ClientTransferProhibitedSupported flag showing if the clientTransferProhibited status is supported for the domain
	ClientTransferProhibitedSupported *bool `json:"clientTransferProhibitedSupported,omitempty"`

	// ClientUpdateProhibitedSupported flag showing if the clientUpdateProhibited status is supported for a domain
	ClientUpdateProhibitedSupported *bool `json:"clientUpdateProhibitedSupported,omitempty"`

	// ContactTypesSupported list of contact types supported by the registry
	ContactTypesSupported *[]TldInfoContactTypesSupported `json:"contactTypesSupported,omitempty"`

	// DnsSecInterface flag which describes which DNSSec interface is supported by the registry
	DnsSecInterface *TldInfoDnsSecInterface `json:"dnsSecInterface,omitempty"`

	// DnsSecSupported flag showing if the TLD supports DNSSec
	DnsSecSupported *bool `json:"dnsSecSupported,omitempty"`

	// EmailVerificationRequired flag describing if a change in registrant data will need the client's confirmation regarding the validity of his email address in order to be applied
	EmailVerificationRequired *bool `json:"emailVerificationRequired,omitempty"`

	// GlueNameserverSupported flag showing if glue nameservers can be created using a domain with that specific TLD
	GlueNameserverSupported *bool `json:"glueNameserverSupported,omitempty"`

	// IdnSupported flag which allows IDN domain names to be registered with that specific TLD
	IdnSupported *bool `json:"idnSupported,omitempty"`

	// PrivateRegistrationSupported flag regarding the private registration feature of the domains which allows contact data to remain private
	PrivateRegistrationSupported *bool `json:"privateRegistrationSupported,omitempty"`

	// RenewSupported flag showing if a domain with that specific TLD can be renewed
	RenewSupported *bool `json:"renewSupported,omitempty"`

	// RestoreSupported flag showing if a domain with that specific TLD can be restored
	RestoreSupported *bool `json:"restoreSupported,omitempty"`

	// TransferSupported flag showing if a domain with that specific TLD can be transferred
	TransferSupported *bool `json:"transferSupported,omitempty"`

	// UpdateNameserverSupported flag showing if domain's nameservers can be updated
	UpdateNameserverSupported *bool `json:"updateNameserverSupported,omitempty"`
}

// TldInfoContactTypesSupported defines model for TldInfo.ContactTypesSupported.
type TldInfoContactTypesSupported string

// TldInfoDnsSecInterface flag which describes which DNSSec interface is supported by the registry
type TldInfoDnsSecInterface string

// TldListResponse List of tlds
type TldListResponse = []string

// TransferInRequest Transfer in request model
type TransferInRequest struct {
	// Action Transfer in action
	Action *TransferInRequestAction `json:"action,omitempty"`

	// AuthCode Authorization code
	AuthCode *string `json:"authCode,omitempty"`
}

// TransferInRequestAction Transfer in action
type TransferInRequestAction string

// TransferOutRequest Transfer out request model
type TransferOutRequest struct {
	// Action Transfer in action
	Action *TransferOutRequestAction `json:"action,omitempty"`
}

// TransferOutRequestAction Transfer in action
type TransferOutRequestAction string

// ValidationError Validation error model
type ValidationError struct {
	// Code The error code.
	Code *string `json:"code,omitempty"`

	// Fields List of  fields causing the error
	Fields *[]string `json:"fields,omitempty"`
}

// GetV1DomainitemsParams defines parameters for GetV1Domainitems.
type GetV1DomainitemsParams struct {
	// Offset The number of items to skip before starting to collect the result set. Default value is set to 0. This parameter should be positive or zero.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return. By default, it is set to 100. This parameter should be greater than zero.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Tld Query by tld
	Tld *string `form:"tld,omitempty" json:"tld,omitempty"`

	// PendingProvisioning If true, the query will return only items which are in pending provisioning. If
	// false, it returns only items which are fully provisioned
	// and if unset, all items will be returned.
	PendingProvisioning *bool `form:"pendingProvisioning,omitempty" json:"pendingProvisioning,omitempty"`

	// Label Query by domain label (exact matching)
	Label *string `form:"label,omitempty" json:"label,omitempty"`

	// LabelPrefix Query by domain label prefix
	LabelPrefix *string `form:"labelPrefix,omitempty" json:"labelPrefix,omitempty"`

	// LabelSuffix Query by domain label suffix
	LabelSuffix *string `form:"labelSuffix,omitempty" json:"labelSuffix,omitempty"`

	// Name Query by a sequence of characters contained in the domain name (minimum length is 3)
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// IncludeDomainStatus If true, it will include status information about the domains.
	IncludeDomainStatus *bool `form:"includeDomainStatus,omitempty" json:"includeDomainStatus,omitempty"`

	// SortBy The criteria to be used for sorting the result list.
	SortBy *GetV1DomainitemsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Direction The sorting direction - ascending, descending.
	Direction *GetV1DomainitemsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// GetV1DomainitemsParamsSortBy defines parameters for GetV1Domainitems.
type GetV1DomainitemsParamsSortBy string

// GetV1DomainitemsParamsDirection defines parameters for GetV1Domainitems.
type GetV1DomainitemsParamsDirection string

// GetV1DomainitemsDomainsParams defines parameters for GetV1DomainitemsDomains.
type GetV1DomainitemsDomainsParams struct {
	// Offset The number of items to skip before starting to collect the result set. Default value is set to 0. This parameter should be positive or zero.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return. By default, it is set to 100. This parameter should be greater than zero.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Name Query by a sequence of characters contained in the domain name (minimum length is 3)
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PendingProvisioning If true, the query will return only items which are in pending provisioning. If
	// false, it returns only items which are fully provisioned
	// and if unset, all items will be returned.
	PendingProvisioning *bool `form:"pendingProvisioning,omitempty" json:"pendingProvisioning,omitempty"`

	// IncludeProvisioningStatus If true, it will include provisioning status information about the domains.
	IncludeProvisioningStatus *bool `form:"includeProvisioningStatus,omitempty" json:"includeProvisioningStatus,omitempty"`

	// SortBy The criteria to be used for sorting the result list.
	SortBy *GetV1DomainitemsDomainsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Direction The sorting direction - ascending, descending.
	Direction *GetV1DomainitemsDomainsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// GetV1DomainitemsDomainsParamsSortBy defines parameters for GetV1DomainitemsDomains.
type GetV1DomainitemsDomainsParamsSortBy string

// GetV1DomainitemsDomainsParamsDirection defines parameters for GetV1DomainitemsDomains.
type GetV1DomainitemsDomainsParamsDirection string

// PostV1DomainitemsPreregistrationsParams defines parameters for PostV1DomainitemsPreregistrations.
type PostV1DomainitemsPreregistrationsParams struct {
	// Limit sets the limit of the result set. used for pagination
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset sets the offset of the result set. used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetV1DomainitemsTldsParams defines parameters for GetV1DomainitemsTlds.
type GetV1DomainitemsTldsParams struct {
	Phase *GetV1DomainitemsTldsParamsPhase `form:"phase,omitempty" json:"phase,omitempty"`
}

// GetV1DomainitemsTldsParamsPhase defines parameters for GetV1DomainitemsTlds.
type GetV1DomainitemsTldsParamsPhase string

// GetV1DomainitemsTransfersParams defines parameters for GetV1DomainitemsTransfers.
type GetV1DomainitemsTransfersParams struct {
	// Limit sets the limit of the result set. used for pagination
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset sets the offset of the result set. used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetV1DomainitemsDomainIdParams defines parameters for GetV1DomainitemsDomainId.
type GetV1DomainitemsDomainIdParams struct {
	// IncludeDomainStatus If true, it will include status information about the domain.
	IncludeDomainStatus *bool `form:"includeDomainStatus,omitempty" json:"includeDomainStatus,omitempty"`
}

// PostV1DomainitemsPreregistrationsJSONRequestBody defines body for PostV1DomainitemsPreregistrations for application/json ContentType.
type PostV1DomainitemsPreregistrationsJSONRequestBody = PreregistrationsBody

// PutV1DomainitemsDomainIdAuthcodeJSONRequestBody defines body for PutV1DomainitemsDomainIdAuthcode for application/json ContentType.
type PutV1DomainitemsDomainIdAuthcodeJSONRequestBody = AuthCodeRequest

// PutV1DomainitemsDomainIdContactsJSONRequestBody defines body for PutV1DomainitemsDomainIdContacts for application/json ContentType.
type PutV1DomainitemsDomainIdContactsJSONRequestBody = Contacts

// PutV1DomainitemsDomainIdDataQualityJSONRequestBody defines body for PutV1DomainitemsDomainIdDataQuality for application/json ContentType.
type PutV1DomainitemsDomainIdDataQualityJSONRequestBody = DataQualityRequest

// PutV1DomainitemsDomainIdDnssecJSONRequestBody defines body for PutV1DomainitemsDomainIdDnssec for application/json ContentType.
type PutV1DomainitemsDomainIdDnssecJSONRequestBody = DnsSec

// PutV1DomainitemsDomainIdEmailVerificationJSONRequestBody defines body for PutV1DomainitemsDomainIdEmailVerification for application/json ContentType.
type PutV1DomainitemsDomainIdEmailVerificationJSONRequestBody = EmailVerificationRequest

// PutV1DomainitemsDomainIdNameserversJSONRequestBody defines body for PutV1DomainitemsDomainIdNameservers for application/json ContentType.
type PutV1DomainitemsDomainIdNameserversJSONRequestBody = Nameservers

// PutV1DomainitemsDomainIdPrivacyJSONRequestBody defines body for PutV1DomainitemsDomainIdPrivacy for application/json ContentType.
type PutV1DomainitemsDomainIdPrivacyJSONRequestBody = DisablePrivacy

// PutV1DomainitemsDomainIdStatusesJSONRequestBody defines body for PutV1DomainitemsDomainIdStatuses for application/json ContentType.
type PutV1DomainitemsDomainIdStatusesJSONRequestBody = DomainStatusesRequest

// PutV1DomainitemsDomainIdTransferInJSONRequestBody defines body for PutV1DomainitemsDomainIdTransferIn for application/json ContentType.
type PutV1DomainitemsDomainIdTransferInJSONRequestBody = TransferInRequest

// PutV1DomainitemsDomainIdTransferOutJSONRequestBody defines body for PutV1DomainitemsDomainIdTransferOut for application/json ContentType.
type PutV1DomainitemsDomainIdTransferOutJSONRequestBody = TransferOutRequest

// PostV1ValidationDomainsJSONRequestBody defines body for PostV1ValidationDomains for application/json ContentType.
type PostV1ValidationDomainsJSONRequestBody = DomainNameValidationRequest

// PostV1ValidationTldContactsJSONRequestBody defines body for PostV1ValidationTldContacts for application/json ContentType.
type PostV1ValidationTldContactsJSONRequestBody = Contact

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetV1Domainitems request
	GetV1Domainitems(ctx context.Context, params *GetV1DomainitemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomains request
	GetV1DomainitemsDomains(ctx context.Context, params *GetV1DomainitemsDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV1DomainitemsPreregistrationsWithBody request with any body
	PostV1DomainitemsPreregistrationsWithBody(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV1DomainitemsPreregistrations(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, body PostV1DomainitemsPreregistrationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsTlds request
	GetV1DomainitemsTlds(ctx context.Context, params *GetV1DomainitemsTldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsTransfers request
	GetV1DomainitemsTransfers(ctx context.Context, params *GetV1DomainitemsTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomainId request
	GetV1DomainitemsDomainId(ctx context.Context, domainId string, params *GetV1DomainitemsDomainIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdAuthcodeWithBody request with any body
	PutV1DomainitemsDomainIdAuthcodeWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdAuthcode(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdAuthcodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomainIdContacts request
	GetV1DomainitemsDomainIdContacts(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdContactsWithBody request with any body
	PutV1DomainitemsDomainIdContactsWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdContacts(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdDataQualityWithBody request with any body
	PutV1DomainitemsDomainIdDataQualityWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdDataQuality(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDataQualityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomainIdDnssec request
	GetV1DomainitemsDomainIdDnssec(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdDnssecWithBody request with any body
	PutV1DomainitemsDomainIdDnssecWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdDnssec(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDnssecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdEmailVerificationWithBody request with any body
	PutV1DomainitemsDomainIdEmailVerificationWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdEmailVerification(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomainIdNameservers request
	GetV1DomainitemsDomainIdNameservers(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdNameserversWithBody request with any body
	PutV1DomainitemsDomainIdNameserversWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdNameservers(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdNameserversJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomainIdOwnership request
	GetV1DomainitemsDomainIdOwnership(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdPrivacyWithBody request with any body
	PutV1DomainitemsDomainIdPrivacyWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdPrivacy(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomainIdRegistrycontacts request
	GetV1DomainitemsDomainIdRegistrycontacts(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1DomainitemsDomainIdStatuses request
	GetV1DomainitemsDomainIdStatuses(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdStatusesWithBody request with any body
	PutV1DomainitemsDomainIdStatusesWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdStatuses(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdStatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdTransferInWithBody request with any body
	PutV1DomainitemsDomainIdTransferInWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdTransferIn(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferInJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV1DomainitemsDomainIdTransferOutWithBody request with any body
	PutV1DomainitemsDomainIdTransferOutWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV1DomainitemsDomainIdTransferOut(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferOutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1RequestsRequestId request
	GetV1RequestsRequestId(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1TldsTld request
	GetV1TldsTld(ctx context.Context, tld string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV1ValidationDomainsWithBody request with any body
	PostV1ValidationDomainsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV1ValidationDomains(ctx context.Context, body PostV1ValidationDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV1ValidationTldContactsWithBody request with any body
	PostV1ValidationTldContactsWithBody(ctx context.Context, tld string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV1ValidationTldContacts(ctx context.Context, tld string, body PostV1ValidationTldContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetV1Domainitems(ctx context.Context, params *GetV1DomainitemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomains(ctx context.Context, params *GetV1DomainitemsDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1DomainitemsPreregistrationsWithBody(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1DomainitemsPreregistrationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1DomainitemsPreregistrations(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, body PostV1DomainitemsPreregistrationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1DomainitemsPreregistrationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsTlds(ctx context.Context, params *GetV1DomainitemsTldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsTldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsTransfers(ctx context.Context, params *GetV1DomainitemsTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsTransfersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomainId(ctx context.Context, domainId string, params *GetV1DomainitemsDomainIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainIdRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdAuthcodeWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdAuthcodeRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdAuthcode(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdAuthcodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdAuthcodeRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomainIdContacts(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainIdContactsRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdContactsWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdContactsRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdContacts(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdContactsRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdDataQualityWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdDataQualityRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdDataQuality(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDataQualityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdDataQualityRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomainIdDnssec(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainIdDnssecRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdDnssecWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdDnssecRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdDnssec(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDnssecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdDnssecRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdEmailVerificationWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdEmailVerificationRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdEmailVerification(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdEmailVerificationRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomainIdNameservers(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainIdNameserversRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdNameserversWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdNameserversRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdNameservers(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdNameserversJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdNameserversRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomainIdOwnership(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainIdOwnershipRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdPrivacyWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdPrivacyRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdPrivacy(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdPrivacyRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomainIdRegistrycontacts(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainIdRegistrycontactsRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1DomainitemsDomainIdStatuses(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1DomainitemsDomainIdStatusesRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdStatusesWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdStatusesRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdStatuses(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdStatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdStatusesRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdTransferInWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdTransferInRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdTransferIn(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferInJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdTransferInRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdTransferOutWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdTransferOutRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV1DomainitemsDomainIdTransferOut(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferOutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV1DomainitemsDomainIdTransferOutRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1RequestsRequestId(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1RequestsRequestIdRequest(c.Server, requestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1TldsTld(ctx context.Context, tld string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1TldsTldRequest(c.Server, tld)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1ValidationDomainsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1ValidationDomainsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1ValidationDomains(ctx context.Context, body PostV1ValidationDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1ValidationDomainsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1ValidationTldContactsWithBody(ctx context.Context, tld string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1ValidationTldContactsRequestWithBody(c.Server, tld, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1ValidationTldContacts(ctx context.Context, tld string, body PostV1ValidationTldContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1ValidationTldContactsRequest(c.Server, tld, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetV1DomainitemsRequest generates requests for GetV1Domainitems
func NewGetV1DomainitemsRequest(server string, params *GetV1DomainitemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tld != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tld", runtime.ParamLocationQuery, *params.Tld); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PendingProvisioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pendingProvisioning", runtime.ParamLocationQuery, *params.PendingProvisioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LabelPrefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labelPrefix", runtime.ParamLocationQuery, *params.LabelPrefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LabelSuffix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labelSuffix", runtime.ParamLocationQuery, *params.LabelSuffix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDomainStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDomainStatus", runtime.ParamLocationQuery, *params.IncludeDomainStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV1DomainitemsDomainsRequest generates requests for GetV1DomainitemsDomains
func NewGetV1DomainitemsDomainsRequest(server string, params *GetV1DomainitemsDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PendingProvisioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pendingProvisioning", runtime.ParamLocationQuery, *params.PendingProvisioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProvisioningStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeProvisioningStatus", runtime.ParamLocationQuery, *params.IncludeProvisioningStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV1DomainitemsPreregistrationsRequest calls the generic PostV1DomainitemsPreregistrations builder with application/json body
func NewPostV1DomainitemsPreregistrationsRequest(server string, params *PostV1DomainitemsPreregistrationsParams, body PostV1DomainitemsPreregistrationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV1DomainitemsPreregistrationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV1DomainitemsPreregistrationsRequestWithBody generates requests for PostV1DomainitemsPreregistrations with any type of body
func NewPostV1DomainitemsPreregistrationsRequestWithBody(server string, params *PostV1DomainitemsPreregistrationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/preregistrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV1DomainitemsTldsRequest generates requests for GetV1DomainitemsTlds
func NewGetV1DomainitemsTldsRequest(server string, params *GetV1DomainitemsTldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/tlds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Phase != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phase", runtime.ParamLocationQuery, *params.Phase); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV1DomainitemsTransfersRequest generates requests for GetV1DomainitemsTransfers
func NewGetV1DomainitemsTransfersRequest(server string, params *GetV1DomainitemsTransfersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/transfers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV1DomainitemsDomainIdRequest generates requests for GetV1DomainitemsDomainId
func NewGetV1DomainitemsDomainIdRequest(server string, domainId string, params *GetV1DomainitemsDomainIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDomainStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDomainStatus", runtime.ParamLocationQuery, *params.IncludeDomainStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutV1DomainitemsDomainIdAuthcodeRequest calls the generic PutV1DomainitemsDomainIdAuthcode builder with application/json body
func NewPutV1DomainitemsDomainIdAuthcodeRequest(server string, domainId string, body PutV1DomainitemsDomainIdAuthcodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdAuthcodeRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdAuthcodeRequestWithBody generates requests for PutV1DomainitemsDomainIdAuthcode with any type of body
func NewPutV1DomainitemsDomainIdAuthcodeRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/authcode", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV1DomainitemsDomainIdContactsRequest generates requests for GetV1DomainitemsDomainIdContacts
func NewGetV1DomainitemsDomainIdContactsRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/contacts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutV1DomainitemsDomainIdContactsRequest calls the generic PutV1DomainitemsDomainIdContacts builder with application/json body
func NewPutV1DomainitemsDomainIdContactsRequest(server string, domainId string, body PutV1DomainitemsDomainIdContactsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdContactsRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdContactsRequestWithBody generates requests for PutV1DomainitemsDomainIdContacts with any type of body
func NewPutV1DomainitemsDomainIdContactsRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/contacts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV1DomainitemsDomainIdDataQualityRequest calls the generic PutV1DomainitemsDomainIdDataQuality builder with application/json body
func NewPutV1DomainitemsDomainIdDataQualityRequest(server string, domainId string, body PutV1DomainitemsDomainIdDataQualityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdDataQualityRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdDataQualityRequestWithBody generates requests for PutV1DomainitemsDomainIdDataQuality with any type of body
func NewPutV1DomainitemsDomainIdDataQualityRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/data_quality", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV1DomainitemsDomainIdDnssecRequest generates requests for GetV1DomainitemsDomainIdDnssec
func NewGetV1DomainitemsDomainIdDnssecRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/dnssec", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutV1DomainitemsDomainIdDnssecRequest calls the generic PutV1DomainitemsDomainIdDnssec builder with application/json body
func NewPutV1DomainitemsDomainIdDnssecRequest(server string, domainId string, body PutV1DomainitemsDomainIdDnssecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdDnssecRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdDnssecRequestWithBody generates requests for PutV1DomainitemsDomainIdDnssec with any type of body
func NewPutV1DomainitemsDomainIdDnssecRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/dnssec", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV1DomainitemsDomainIdEmailVerificationRequest calls the generic PutV1DomainitemsDomainIdEmailVerification builder with application/json body
func NewPutV1DomainitemsDomainIdEmailVerificationRequest(server string, domainId string, body PutV1DomainitemsDomainIdEmailVerificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdEmailVerificationRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdEmailVerificationRequestWithBody generates requests for PutV1DomainitemsDomainIdEmailVerification with any type of body
func NewPutV1DomainitemsDomainIdEmailVerificationRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/email_verification", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV1DomainitemsDomainIdNameserversRequest generates requests for GetV1DomainitemsDomainIdNameservers
func NewGetV1DomainitemsDomainIdNameserversRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/nameservers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutV1DomainitemsDomainIdNameserversRequest calls the generic PutV1DomainitemsDomainIdNameservers builder with application/json body
func NewPutV1DomainitemsDomainIdNameserversRequest(server string, domainId string, body PutV1DomainitemsDomainIdNameserversJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdNameserversRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdNameserversRequestWithBody generates requests for PutV1DomainitemsDomainIdNameservers with any type of body
func NewPutV1DomainitemsDomainIdNameserversRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/nameservers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV1DomainitemsDomainIdOwnershipRequest generates requests for GetV1DomainitemsDomainIdOwnership
func NewGetV1DomainitemsDomainIdOwnershipRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/ownership", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutV1DomainitemsDomainIdPrivacyRequest calls the generic PutV1DomainitemsDomainIdPrivacy builder with application/json body
func NewPutV1DomainitemsDomainIdPrivacyRequest(server string, domainId string, body PutV1DomainitemsDomainIdPrivacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdPrivacyRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdPrivacyRequestWithBody generates requests for PutV1DomainitemsDomainIdPrivacy with any type of body
func NewPutV1DomainitemsDomainIdPrivacyRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/privacy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV1DomainitemsDomainIdRegistrycontactsRequest generates requests for GetV1DomainitemsDomainIdRegistrycontacts
func NewGetV1DomainitemsDomainIdRegistrycontactsRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/registrycontacts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV1DomainitemsDomainIdStatusesRequest generates requests for GetV1DomainitemsDomainIdStatuses
func NewGetV1DomainitemsDomainIdStatusesRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/statuses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutV1DomainitemsDomainIdStatusesRequest calls the generic PutV1DomainitemsDomainIdStatuses builder with application/json body
func NewPutV1DomainitemsDomainIdStatusesRequest(server string, domainId string, body PutV1DomainitemsDomainIdStatusesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdStatusesRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdStatusesRequestWithBody generates requests for PutV1DomainitemsDomainIdStatuses with any type of body
func NewPutV1DomainitemsDomainIdStatusesRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/statuses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV1DomainitemsDomainIdTransferInRequest calls the generic PutV1DomainitemsDomainIdTransferIn builder with application/json body
func NewPutV1DomainitemsDomainIdTransferInRequest(server string, domainId string, body PutV1DomainitemsDomainIdTransferInJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdTransferInRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdTransferInRequestWithBody generates requests for PutV1DomainitemsDomainIdTransferIn with any type of body
func NewPutV1DomainitemsDomainIdTransferInRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/transfer_in", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV1DomainitemsDomainIdTransferOutRequest calls the generic PutV1DomainitemsDomainIdTransferOut builder with application/json body
func NewPutV1DomainitemsDomainIdTransferOutRequest(server string, domainId string, body PutV1DomainitemsDomainIdTransferOutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV1DomainitemsDomainIdTransferOutRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPutV1DomainitemsDomainIdTransferOutRequestWithBody generates requests for PutV1DomainitemsDomainIdTransferOut with any type of body
func NewPutV1DomainitemsDomainIdTransferOutRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domainitems/%s/transfer_out", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV1RequestsRequestIdRequest generates requests for GetV1RequestsRequestId
func NewGetV1RequestsRequestIdRequest(server string, requestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "requestId", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV1TldsTldRequest generates requests for GetV1TldsTld
func NewGetV1TldsTldRequest(server string, tld string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tld", runtime.ParamLocationPath, tld)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tlds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV1ValidationDomainsRequest calls the generic PostV1ValidationDomains builder with application/json body
func NewPostV1ValidationDomainsRequest(server string, body PostV1ValidationDomainsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV1ValidationDomainsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV1ValidationDomainsRequestWithBody generates requests for PostV1ValidationDomains with any type of body
func NewPostV1ValidationDomainsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/validation/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV1ValidationTldContactsRequest calls the generic PostV1ValidationTldContacts builder with application/json body
func NewPostV1ValidationTldContactsRequest(server string, tld string, body PostV1ValidationTldContactsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV1ValidationTldContactsRequestWithBody(server, tld, "application/json", bodyReader)
}

// NewPostV1ValidationTldContactsRequestWithBody generates requests for PostV1ValidationTldContacts with any type of body
func NewPostV1ValidationTldContactsRequestWithBody(server string, tld string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tld", runtime.ParamLocationPath, tld)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/validation/%s/contacts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetV1DomainitemsWithResponse request
	GetV1DomainitemsWithResponse(ctx context.Context, params *GetV1DomainitemsParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsResponse, error)

	// GetV1DomainitemsDomainsWithResponse request
	GetV1DomainitemsDomainsWithResponse(ctx context.Context, params *GetV1DomainitemsDomainsParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainsResponse, error)

	// PostV1DomainitemsPreregistrationsWithBodyWithResponse request with any body
	PostV1DomainitemsPreregistrationsWithBodyWithResponse(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1DomainitemsPreregistrationsResponse, error)

	PostV1DomainitemsPreregistrationsWithResponse(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, body PostV1DomainitemsPreregistrationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1DomainitemsPreregistrationsResponse, error)

	// GetV1DomainitemsTldsWithResponse request
	GetV1DomainitemsTldsWithResponse(ctx context.Context, params *GetV1DomainitemsTldsParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsTldsResponse, error)

	// GetV1DomainitemsTransfersWithResponse request
	GetV1DomainitemsTransfersWithResponse(ctx context.Context, params *GetV1DomainitemsTransfersParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsTransfersResponse, error)

	// GetV1DomainitemsDomainIdWithResponse request
	GetV1DomainitemsDomainIdWithResponse(ctx context.Context, domainId string, params *GetV1DomainitemsDomainIdParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdResponse, error)

	// PutV1DomainitemsDomainIdAuthcodeWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdAuthcodeWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdAuthcodeResponse, error)

	PutV1DomainitemsDomainIdAuthcodeWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdAuthcodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdAuthcodeResponse, error)

	// GetV1DomainitemsDomainIdContactsWithResponse request
	GetV1DomainitemsDomainIdContactsWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdContactsResponse, error)

	// PutV1DomainitemsDomainIdContactsWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdContactsWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdContactsResponse, error)

	PutV1DomainitemsDomainIdContactsWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdContactsResponse, error)

	// PutV1DomainitemsDomainIdDataQualityWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdDataQualityWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDataQualityResponse, error)

	PutV1DomainitemsDomainIdDataQualityWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDataQualityJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDataQualityResponse, error)

	// GetV1DomainitemsDomainIdDnssecWithResponse request
	GetV1DomainitemsDomainIdDnssecWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdDnssecResponse, error)

	// PutV1DomainitemsDomainIdDnssecWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdDnssecWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDnssecResponse, error)

	PutV1DomainitemsDomainIdDnssecWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDnssecJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDnssecResponse, error)

	// PutV1DomainitemsDomainIdEmailVerificationWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdEmailVerificationWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdEmailVerificationResponse, error)

	PutV1DomainitemsDomainIdEmailVerificationWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdEmailVerificationResponse, error)

	// GetV1DomainitemsDomainIdNameserversWithResponse request
	GetV1DomainitemsDomainIdNameserversWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdNameserversResponse, error)

	// PutV1DomainitemsDomainIdNameserversWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdNameserversWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdNameserversResponse, error)

	PutV1DomainitemsDomainIdNameserversWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdNameserversJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdNameserversResponse, error)

	// GetV1DomainitemsDomainIdOwnershipWithResponse request
	GetV1DomainitemsDomainIdOwnershipWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdOwnershipResponse, error)

	// PutV1DomainitemsDomainIdPrivacyWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdPrivacyWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdPrivacyResponse, error)

	PutV1DomainitemsDomainIdPrivacyWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdPrivacyResponse, error)

	// GetV1DomainitemsDomainIdRegistrycontactsWithResponse request
	GetV1DomainitemsDomainIdRegistrycontactsWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdRegistrycontactsResponse, error)

	// GetV1DomainitemsDomainIdStatusesWithResponse request
	GetV1DomainitemsDomainIdStatusesWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdStatusesResponse, error)

	// PutV1DomainitemsDomainIdStatusesWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdStatusesWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdStatusesResponse, error)

	PutV1DomainitemsDomainIdStatusesWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdStatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdStatusesResponse, error)

	// PutV1DomainitemsDomainIdTransferInWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdTransferInWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferInResponse, error)

	PutV1DomainitemsDomainIdTransferInWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferInJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferInResponse, error)

	// PutV1DomainitemsDomainIdTransferOutWithBodyWithResponse request with any body
	PutV1DomainitemsDomainIdTransferOutWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferOutResponse, error)

	PutV1DomainitemsDomainIdTransferOutWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferOutJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferOutResponse, error)

	// GetV1RequestsRequestIdWithResponse request
	GetV1RequestsRequestIdWithResponse(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*GetV1RequestsRequestIdResponse, error)

	// GetV1TldsTldWithResponse request
	GetV1TldsTldWithResponse(ctx context.Context, tld string, reqEditors ...RequestEditorFn) (*GetV1TldsTldResponse, error)

	// PostV1ValidationDomainsWithBodyWithResponse request with any body
	PostV1ValidationDomainsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1ValidationDomainsResponse, error)

	PostV1ValidationDomainsWithResponse(ctx context.Context, body PostV1ValidationDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1ValidationDomainsResponse, error)

	// PostV1ValidationTldContactsWithBodyWithResponse request with any body
	PostV1ValidationTldContactsWithBodyWithResponse(ctx context.Context, tld string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1ValidationTldContactsResponse, error)

	PostV1ValidationTldContactsWithResponse(ctx context.Context, tld string, body PostV1ValidationTldContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1ValidationTldContactsResponse, error)
}

type GetV1DomainitemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Domains
	JSON400      *[]Error
	JSON401      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DomainsSlim
	JSON400      *[]Error
	JSON401      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV1DomainitemsPreregistrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreregistrationsResponse
}

// Status returns HTTPResponse.Status
func (r PostV1DomainitemsPreregistrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV1DomainitemsPreregistrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsTldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TldListResponse
	JSON401      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsTldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsTldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsTransfersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunningTransfersResponse
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsTransfersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsTransfersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DomainLarge
	JSON401      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdAuthcodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RequestId
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdAuthcodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdAuthcodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainIdContactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Contact
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainIdContactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainIdContactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdContactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RequestId
	JSON400      *[]Error
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdContactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdContactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdDataQualityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *[]Error
	JSON401      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdDataQualityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdDataQualityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainIdDnssecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnsSec
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainIdDnssecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainIdDnssecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdDnssecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RequestId
	JSON400      *[]Error
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdDnssecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdDnssecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdEmailVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *EmailVerificationResponse
	JSON400      *[]Error
	JSON401      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdEmailVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdEmailVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainIdNameserversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameserverGetResponse
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainIdNameserversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainIdNameserversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdNameserversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RequestId
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdNameserversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdNameserversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainIdOwnershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainIdOwnershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainIdOwnershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdPrivacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RequestId
	JSON400      *[]Error
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdPrivacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdPrivacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainIdRegistrycontactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Contact
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainIdRegistrycontactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainIdRegistrycontactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1DomainitemsDomainIdStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DomainStatusesResponse
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1DomainitemsDomainIdStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1DomainitemsDomainIdStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RequestId
	JSON400      *[]Error
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdTransferInResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *[]Error
	JSON401      *[]Error
	JSON403      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdTransferInResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdTransferInResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV1DomainitemsDomainIdTransferOutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *[]Error
	JSON401      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PutV1DomainitemsDomainIdTransferOutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV1DomainitemsDomainIdTransferOutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1RequestsRequestIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestResponse
	JSON401      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1RequestsRequestIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1RequestsRequestIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1TldsTldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TldInfo
	JSON401      *[]Error
	JSON404      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r GetV1TldsTldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1TldsTldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV1ValidationDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidationError
	JSON400      *[]Error
	JSON401      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PostV1ValidationDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV1ValidationDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV1ValidationTldContactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidationError
	JSON400      *[]Error
	JSON401      *[]Error
	JSON500      *[]Error
}

// Status returns HTTPResponse.Status
func (r PostV1ValidationTldContactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV1ValidationTldContactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetV1DomainitemsWithResponse request returning *GetV1DomainitemsResponse
func (c *ClientWithResponses) GetV1DomainitemsWithResponse(ctx context.Context, params *GetV1DomainitemsParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsResponse, error) {
	rsp, err := c.GetV1Domainitems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsResponse(rsp)
}

// GetV1DomainitemsDomainsWithResponse request returning *GetV1DomainitemsDomainsResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainsWithResponse(ctx context.Context, params *GetV1DomainitemsDomainsParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainsResponse, error) {
	rsp, err := c.GetV1DomainitemsDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainsResponse(rsp)
}

// PostV1DomainitemsPreregistrationsWithBodyWithResponse request with arbitrary body returning *PostV1DomainitemsPreregistrationsResponse
func (c *ClientWithResponses) PostV1DomainitemsPreregistrationsWithBodyWithResponse(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1DomainitemsPreregistrationsResponse, error) {
	rsp, err := c.PostV1DomainitemsPreregistrationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1DomainitemsPreregistrationsResponse(rsp)
}

func (c *ClientWithResponses) PostV1DomainitemsPreregistrationsWithResponse(ctx context.Context, params *PostV1DomainitemsPreregistrationsParams, body PostV1DomainitemsPreregistrationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1DomainitemsPreregistrationsResponse, error) {
	rsp, err := c.PostV1DomainitemsPreregistrations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1DomainitemsPreregistrationsResponse(rsp)
}

// GetV1DomainitemsTldsWithResponse request returning *GetV1DomainitemsTldsResponse
func (c *ClientWithResponses) GetV1DomainitemsTldsWithResponse(ctx context.Context, params *GetV1DomainitemsTldsParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsTldsResponse, error) {
	rsp, err := c.GetV1DomainitemsTlds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsTldsResponse(rsp)
}

// GetV1DomainitemsTransfersWithResponse request returning *GetV1DomainitemsTransfersResponse
func (c *ClientWithResponses) GetV1DomainitemsTransfersWithResponse(ctx context.Context, params *GetV1DomainitemsTransfersParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsTransfersResponse, error) {
	rsp, err := c.GetV1DomainitemsTransfers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsTransfersResponse(rsp)
}

// GetV1DomainitemsDomainIdWithResponse request returning *GetV1DomainitemsDomainIdResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainIdWithResponse(ctx context.Context, domainId string, params *GetV1DomainitemsDomainIdParams, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdResponse, error) {
	rsp, err := c.GetV1DomainitemsDomainId(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainIdResponse(rsp)
}

// PutV1DomainitemsDomainIdAuthcodeWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdAuthcodeResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdAuthcodeWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdAuthcodeResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdAuthcodeWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdAuthcodeResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdAuthcodeWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdAuthcodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdAuthcodeResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdAuthcode(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdAuthcodeResponse(rsp)
}

// GetV1DomainitemsDomainIdContactsWithResponse request returning *GetV1DomainitemsDomainIdContactsResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainIdContactsWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdContactsResponse, error) {
	rsp, err := c.GetV1DomainitemsDomainIdContacts(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainIdContactsResponse(rsp)
}

// PutV1DomainitemsDomainIdContactsWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdContactsResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdContactsWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdContactsResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdContactsWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdContactsResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdContactsWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdContactsResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdContacts(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdContactsResponse(rsp)
}

// PutV1DomainitemsDomainIdDataQualityWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdDataQualityResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdDataQualityWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDataQualityResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdDataQualityWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdDataQualityResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdDataQualityWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDataQualityJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDataQualityResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdDataQuality(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdDataQualityResponse(rsp)
}

// GetV1DomainitemsDomainIdDnssecWithResponse request returning *GetV1DomainitemsDomainIdDnssecResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainIdDnssecWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdDnssecResponse, error) {
	rsp, err := c.GetV1DomainitemsDomainIdDnssec(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainIdDnssecResponse(rsp)
}

// PutV1DomainitemsDomainIdDnssecWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdDnssecResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdDnssecWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDnssecResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdDnssecWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdDnssecResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdDnssecWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdDnssecJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdDnssecResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdDnssec(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdDnssecResponse(rsp)
}

// PutV1DomainitemsDomainIdEmailVerificationWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdEmailVerificationResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdEmailVerificationWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdEmailVerificationResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdEmailVerificationWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdEmailVerificationResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdEmailVerificationWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdEmailVerificationResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdEmailVerification(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdEmailVerificationResponse(rsp)
}

// GetV1DomainitemsDomainIdNameserversWithResponse request returning *GetV1DomainitemsDomainIdNameserversResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainIdNameserversWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdNameserversResponse, error) {
	rsp, err := c.GetV1DomainitemsDomainIdNameservers(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainIdNameserversResponse(rsp)
}

// PutV1DomainitemsDomainIdNameserversWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdNameserversResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdNameserversWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdNameserversResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdNameserversWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdNameserversResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdNameserversWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdNameserversJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdNameserversResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdNameservers(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdNameserversResponse(rsp)
}

// GetV1DomainitemsDomainIdOwnershipWithResponse request returning *GetV1DomainitemsDomainIdOwnershipResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainIdOwnershipWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdOwnershipResponse, error) {
	rsp, err := c.GetV1DomainitemsDomainIdOwnership(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainIdOwnershipResponse(rsp)
}

// PutV1DomainitemsDomainIdPrivacyWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdPrivacyResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdPrivacyWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdPrivacyResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdPrivacyWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdPrivacyResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdPrivacyWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdPrivacyResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdPrivacy(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdPrivacyResponse(rsp)
}

// GetV1DomainitemsDomainIdRegistrycontactsWithResponse request returning *GetV1DomainitemsDomainIdRegistrycontactsResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainIdRegistrycontactsWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdRegistrycontactsResponse, error) {
	rsp, err := c.GetV1DomainitemsDomainIdRegistrycontacts(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainIdRegistrycontactsResponse(rsp)
}

// GetV1DomainitemsDomainIdStatusesWithResponse request returning *GetV1DomainitemsDomainIdStatusesResponse
func (c *ClientWithResponses) GetV1DomainitemsDomainIdStatusesWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetV1DomainitemsDomainIdStatusesResponse, error) {
	rsp, err := c.GetV1DomainitemsDomainIdStatuses(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1DomainitemsDomainIdStatusesResponse(rsp)
}

// PutV1DomainitemsDomainIdStatusesWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdStatusesResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdStatusesWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdStatusesResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdStatusesWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdStatusesResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdStatusesWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdStatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdStatusesResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdStatuses(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdStatusesResponse(rsp)
}

// PutV1DomainitemsDomainIdTransferInWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdTransferInResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdTransferInWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferInResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdTransferInWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdTransferInResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdTransferInWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferInJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferInResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdTransferIn(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdTransferInResponse(rsp)
}

// PutV1DomainitemsDomainIdTransferOutWithBodyWithResponse request with arbitrary body returning *PutV1DomainitemsDomainIdTransferOutResponse
func (c *ClientWithResponses) PutV1DomainitemsDomainIdTransferOutWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferOutResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdTransferOutWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdTransferOutResponse(rsp)
}

func (c *ClientWithResponses) PutV1DomainitemsDomainIdTransferOutWithResponse(ctx context.Context, domainId string, body PutV1DomainitemsDomainIdTransferOutJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV1DomainitemsDomainIdTransferOutResponse, error) {
	rsp, err := c.PutV1DomainitemsDomainIdTransferOut(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV1DomainitemsDomainIdTransferOutResponse(rsp)
}

// GetV1RequestsRequestIdWithResponse request returning *GetV1RequestsRequestIdResponse
func (c *ClientWithResponses) GetV1RequestsRequestIdWithResponse(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*GetV1RequestsRequestIdResponse, error) {
	rsp, err := c.GetV1RequestsRequestId(ctx, requestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1RequestsRequestIdResponse(rsp)
}

// GetV1TldsTldWithResponse request returning *GetV1TldsTldResponse
func (c *ClientWithResponses) GetV1TldsTldWithResponse(ctx context.Context, tld string, reqEditors ...RequestEditorFn) (*GetV1TldsTldResponse, error) {
	rsp, err := c.GetV1TldsTld(ctx, tld, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1TldsTldResponse(rsp)
}

// PostV1ValidationDomainsWithBodyWithResponse request with arbitrary body returning *PostV1ValidationDomainsResponse
func (c *ClientWithResponses) PostV1ValidationDomainsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1ValidationDomainsResponse, error) {
	rsp, err := c.PostV1ValidationDomainsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1ValidationDomainsResponse(rsp)
}

func (c *ClientWithResponses) PostV1ValidationDomainsWithResponse(ctx context.Context, body PostV1ValidationDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1ValidationDomainsResponse, error) {
	rsp, err := c.PostV1ValidationDomains(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1ValidationDomainsResponse(rsp)
}

// PostV1ValidationTldContactsWithBodyWithResponse request with arbitrary body returning *PostV1ValidationTldContactsResponse
func (c *ClientWithResponses) PostV1ValidationTldContactsWithBodyWithResponse(ctx context.Context, tld string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1ValidationTldContactsResponse, error) {
	rsp, err := c.PostV1ValidationTldContactsWithBody(ctx, tld, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1ValidationTldContactsResponse(rsp)
}

func (c *ClientWithResponses) PostV1ValidationTldContactsWithResponse(ctx context.Context, tld string, body PostV1ValidationTldContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1ValidationTldContactsResponse, error) {
	rsp, err := c.PostV1ValidationTldContacts(ctx, tld, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1ValidationTldContactsResponse(rsp)
}

// ParseGetV1DomainitemsResponse parses an HTTP response from a GetV1DomainitemsWithResponse call
func ParseGetV1DomainitemsResponse(rsp *http.Response) (*GetV1DomainitemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Domains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainsResponse parses an HTTP response from a GetV1DomainitemsDomainsWithResponse call
func ParseGetV1DomainitemsDomainsResponse(rsp *http.Response) (*GetV1DomainitemsDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainsSlim
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV1DomainitemsPreregistrationsResponse parses an HTTP response from a PostV1DomainitemsPreregistrationsWithResponse call
func ParsePostV1DomainitemsPreregistrationsResponse(rsp *http.Response) (*PostV1DomainitemsPreregistrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV1DomainitemsPreregistrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreregistrationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsTldsResponse parses an HTTP response from a GetV1DomainitemsTldsWithResponse call
func ParseGetV1DomainitemsTldsResponse(rsp *http.Response) (*GetV1DomainitemsTldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsTldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TldListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsTransfersResponse parses an HTTP response from a GetV1DomainitemsTransfersWithResponse call
func ParseGetV1DomainitemsTransfersResponse(rsp *http.Response) (*GetV1DomainitemsTransfersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsTransfersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunningTransfersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainIdResponse parses an HTTP response from a GetV1DomainitemsDomainIdWithResponse call
func ParseGetV1DomainitemsDomainIdResponse(rsp *http.Response) (*GetV1DomainitemsDomainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdAuthcodeResponse parses an HTTP response from a PutV1DomainitemsDomainIdAuthcodeWithResponse call
func ParsePutV1DomainitemsDomainIdAuthcodeResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdAuthcodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdAuthcodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RequestId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainIdContactsResponse parses an HTTP response from a GetV1DomainitemsDomainIdContactsWithResponse call
func ParseGetV1DomainitemsDomainIdContactsResponse(rsp *http.Response) (*GetV1DomainitemsDomainIdContactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainIdContactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Contact
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdContactsResponse parses an HTTP response from a PutV1DomainitemsDomainIdContactsWithResponse call
func ParsePutV1DomainitemsDomainIdContactsResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdContactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdContactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RequestId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdDataQualityResponse parses an HTTP response from a PutV1DomainitemsDomainIdDataQualityWithResponse call
func ParsePutV1DomainitemsDomainIdDataQualityResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdDataQualityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdDataQualityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainIdDnssecResponse parses an HTTP response from a GetV1DomainitemsDomainIdDnssecWithResponse call
func ParseGetV1DomainitemsDomainIdDnssecResponse(rsp *http.Response) (*GetV1DomainitemsDomainIdDnssecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainIdDnssecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnsSec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdDnssecResponse parses an HTTP response from a PutV1DomainitemsDomainIdDnssecWithResponse call
func ParsePutV1DomainitemsDomainIdDnssecResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdDnssecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdDnssecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RequestId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdEmailVerificationResponse parses an HTTP response from a PutV1DomainitemsDomainIdEmailVerificationWithResponse call
func ParsePutV1DomainitemsDomainIdEmailVerificationResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdEmailVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdEmailVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest EmailVerificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainIdNameserversResponse parses an HTTP response from a GetV1DomainitemsDomainIdNameserversWithResponse call
func ParseGetV1DomainitemsDomainIdNameserversResponse(rsp *http.Response) (*GetV1DomainitemsDomainIdNameserversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainIdNameserversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameserverGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdNameserversResponse parses an HTTP response from a PutV1DomainitemsDomainIdNameserversWithResponse call
func ParsePutV1DomainitemsDomainIdNameserversResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdNameserversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdNameserversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RequestId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainIdOwnershipResponse parses an HTTP response from a GetV1DomainitemsDomainIdOwnershipWithResponse call
func ParseGetV1DomainitemsDomainIdOwnershipResponse(rsp *http.Response) (*GetV1DomainitemsDomainIdOwnershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainIdOwnershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdPrivacyResponse parses an HTTP response from a PutV1DomainitemsDomainIdPrivacyWithResponse call
func ParsePutV1DomainitemsDomainIdPrivacyResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdPrivacyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdPrivacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RequestId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainIdRegistrycontactsResponse parses an HTTP response from a GetV1DomainitemsDomainIdRegistrycontactsWithResponse call
func ParseGetV1DomainitemsDomainIdRegistrycontactsResponse(rsp *http.Response) (*GetV1DomainitemsDomainIdRegistrycontactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainIdRegistrycontactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Contact
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1DomainitemsDomainIdStatusesResponse parses an HTTP response from a GetV1DomainitemsDomainIdStatusesWithResponse call
func ParseGetV1DomainitemsDomainIdStatusesResponse(rsp *http.Response) (*GetV1DomainitemsDomainIdStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1DomainitemsDomainIdStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainStatusesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdStatusesResponse parses an HTTP response from a PutV1DomainitemsDomainIdStatusesWithResponse call
func ParsePutV1DomainitemsDomainIdStatusesResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RequestId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdTransferInResponse parses an HTTP response from a PutV1DomainitemsDomainIdTransferInWithResponse call
func ParsePutV1DomainitemsDomainIdTransferInResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdTransferInResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdTransferInResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV1DomainitemsDomainIdTransferOutResponse parses an HTTP response from a PutV1DomainitemsDomainIdTransferOutWithResponse call
func ParsePutV1DomainitemsDomainIdTransferOutResponse(rsp *http.Response) (*PutV1DomainitemsDomainIdTransferOutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV1DomainitemsDomainIdTransferOutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1RequestsRequestIdResponse parses an HTTP response from a GetV1RequestsRequestIdWithResponse call
func ParseGetV1RequestsRequestIdResponse(rsp *http.Response) (*GetV1RequestsRequestIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1RequestsRequestIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV1TldsTldResponse parses an HTTP response from a GetV1TldsTldWithResponse call
func ParseGetV1TldsTldResponse(rsp *http.Response) (*GetV1TldsTldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1TldsTldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TldInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV1ValidationDomainsResponse parses an HTTP response from a PostV1ValidationDomainsWithResponse call
func ParsePostV1ValidationDomainsResponse(rsp *http.Response) (*PostV1ValidationDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV1ValidationDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV1ValidationTldContactsResponse parses an HTTP response from a PostV1ValidationTldContactsWithResponse call
func ParsePostV1ValidationTldContactsResponse(rsp *http.Response) (*PostV1ValidationTldContactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV1ValidationTldContactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
